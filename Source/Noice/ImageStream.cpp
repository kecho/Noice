#include <noice/noice.h>
#include <ImfChannelList.h>
#include <ImfOutputFile.h>
#include <ImfInputFile.h>
#include <ImfStringAttribute.h>
#include <ImfIO.h>
#include <iostream>
#include "Image.h"
#include "ImageStream.h"

namespace noice
{

extern const char* g_noiceVersion;

namespace
{

void signExr(Imf::Header& header)
{
    std::stringstream ss;
    ss << "This EXR was generated by Noice, a tool by Kleber A. Garcia. Version " << g_noiceVersion;

    header.insert("comments", Imf::StringAttribute(ss.str().c_str()));
    header.insert("noice-version", Imf::StringAttribute(g_noiceVersion));
}

}

class StreamWrapper : public Imf::OStream
{
public:
    StreamWrapper(OutputStream& ostream, const char* filename) : m_ostream(ostream), OStream(filename) {}

    virtual void write (const char c[], int n) 
    {
        m_ostream.write(c, n);
        m_p += n;
    }

    virtual Imath::Int64 tellp ()
    {
        return (Imath::Int64)m_p;
    }

    virtual void seekp (Imath::Int64 pos) 
    {
        m_p = pos;
    }

private:
    Imath::Int64 m_p = 0;
    OutputStream& m_ostream;

};

Error streamOutImage(
    const char* filename,
    OutputStream& output,
    int width, int height, int depth,
    const Channel* rgba[4])
{
    if (width == 0 || height == 0 || depth == 0)
        return Error::BadArgs;
    
    const char* channelNames[] = { "R", "G", "B", "A" };
    StreamWrapper sw(output, filename);
    int scanLines = height * depth;
    Imf::Header header(width, scanLines);

    signExr(header);

    for (int c = 0; c < 4; ++c)
    {
        if (rgba[c] == nullptr || rgba[c]->image == nullptr)
            continue;

        header.channels().insert(channelNames[c], Imf::Channel(Imf::FLOAT));
    }

    try {
        Imf::OutputFile file(sw, header);
        Imf::FrameBuffer frameBuffer;
        for (int c = 0; c < 4; ++c)
        {
            if (rgba[c] == nullptr || rgba[c]->image == nullptr)
                continue;

            frameBuffer.insert(
                channelNames[c], Imf::Slice(
                    Imf::FLOAT, (char*)rgba[c]->image->img().data,
                    sizeof(float),
                    sizeof(float) * width));

        }

        file.setFrameBuffer(frameBuffer);
        file.writePixels(scanLines);
    } catch (const std::exception& exc) {
        std::cerr << exc.what() << std::endl;
        return Error::IoIssue;
    }

    return Error::Ok;
}

Error streamInImage(
    const char* filename,
    Channel outputChannels[4])
{
    try
    {
        Imf::InputFile inputFile(filename);
        Imath::Box2i dw = inputFile.header().dataWindow();
        int width = dw.max.x - dw.min.x + 1;
        int height = dw.max.y - dw.min.y + 1;
        int depth = 1;

        Imf::FrameBuffer frameBuffer;
        const Imf::ChannelList& channels = inputFile.header().channels();
        const char* channelNames[4] = { "R", "G", "B", "A" };
        for (int channelId = 0; channelId < 4; ++channelId)
        {
            const Imf::Channel* channelObject = channels.findChannel(channelNames[channelId]);        
            if (channelObject == nullptr)
                continue;

            if (channelObject->type != Imf::PixelType::FLOAT)
            {
                std::cerr << "Warning: channel" << channelNames[channelId] << "of " << filename << "Must be a float. It will be ignored." << std::endl;
                continue;
            }

            if (channelObject->xSampling > 1 || channelObject->ySampling > 1)
            {
                std::cerr << "Warning: channel" << channelNames[channelId] << "of " << filename
                    << "Must have sampling amount of 1 for x and y. Found x " << channelObject->xSampling
                    << " and y " << channelObject->ySampling << std::endl;
                continue;
            }

            auto* image = new Image();
            outputChannels[channelId].image = image;
            image->init(width, height, depth);

            frameBuffer.insert (
                channelNames[channelId],
                Imf::Slice (
                    Imf::PixelType::FLOAT, // type
                    (char*)image->img().data,
                    sizeof(float),
                    sizeof(float)*width)
            );
        }

        inputFile.setFrameBuffer(frameBuffer);
        inputFile.readPixels(0, height - 1);
    }
    catch (const std::exception& exc)
    {
        std::cerr << exc.what() << std::endl;
        return Error::IoIssue;
    }
    return Error::Ok;
}

}
