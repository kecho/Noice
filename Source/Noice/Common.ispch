#pragma once

typedef uint32<2> uint2;
typedef int32<2> int2;
typedef float<2> float2;
typedef int32<3> int3;
typedef float<3> float3;

inline uint min_u(uint a, uint b)
{
	return a < b ? a : b;
}

inline uint min_i(int a, int b)
{
	return a < b ? a : b;
}

inline float min_f(float a, float b)
{
	return a < b ? a : b;
}

inline int abs_i(int a)
{
	return a > 0 ? a : -a;
}

inline float abs_f(float v)
{
	return v > 0 ? v : -v;
}

inline float2 abs_f2(float2 v)
{
	float2 ans = { v.x > 0 ? v.x : -v.x, v.y > 0 ? v.y : -v.y };
    return ans;
}

inline float dot_f2(float2 a, float2 b)
{
    return (a.x*b.x + b.y*a.y);
}

inline float dot_f3(float3 a, float3 b)
{
    return (a.x*b.x + b.y*a.y + a.z*b.z);
}

inline uint2 min_u2(uint2 a, uint2 b)
{
	uint2 r = { min_u(a.x,b.x), min_u(a.y, b.y) }; 
	return r;
}

inline float2 min_f2(float2 a, float2 b)
{
	float2 r = { min_f(a.x,b.x), min_f(a.y, b.y) }; 
	return r;
}

inline int2 abs_i2(int2 v)
{
	int2 r = { abs_i(v.x), abs_i(v.y) };
	return r;
}

inline int3 abs_i3(int3 v)
{
	int3 r = { abs_i(v.x), abs_i(v.y), abs_i(v.z) };
	return r;
}

inline int2 min_i2(int2 a, int2 b)
{
	int2 r = { min_i(a.x,b.x), min_i(a.y, b.y) }; 
	return r;
}

inline int3 min_i3(int3 a, int3 b)
{
	int3 r = { min_i(a.x,b.x), min_i(a.y, b.y), min_i(a.z, b.z) }; 
	return r;
}

inline float fract(float v)
{
	return abs_f(v) - (float)(abs_i((int)v));
}

//Sampling utilities http://holger.dammertz.org/stuff/notes_HammersleyOnHemisphere.html
inline float radicalInverse(int bits)
{
    bits = (bits << 16u) | (bits >> 16u);
    bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);
    bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);
    bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);
    bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);
    return (float)bits * 2.3283064365386963e-10; // / 0x100000000
}

inline float2 hammersley2d(int i, int N)
{
    float2 ret = { (float)i/(float)N, radicalInverse(i) };
    return ret;
}

inline float3 hemisphereSampleUniform(float u, float v)
{
    float phi = v * 2.0 * PI;
    float cosTheta = 1.0 - u;
    float sinTheta = sqrt(1.0 - cosTheta * cosTheta);
    float3 ret = { cos(phi) * sinTheta, sin(phi) * sinTheta, cosTheta };
    return ret;
}
   
inline float3 hemisphereSampleCos(float u, float v)
{
    float phi = v * 2.0 * PI;
    float cosTheta = sqrt(1.0 - u);
    float sinTheta = sqrt(1.0 - cosTheta * cosTheta);
    float3 ret = { cos(phi) * sinTheta, sin(phi) * sinTheta, cosTheta };
    return ret;
}

inline float3 sphereSample(float u, float v)
{
    float phi = v * 2.0 * PI;
    float cosTheta = 2.0*u - 1;
    float sinTheta = sqrt(1.0 - cosTheta * cosTheta);
    float3 ret = { cos(phi) * sinTheta, sin(phi) * sinTheta, cosTheta };
    return ret;
}

// LCG values from Numerical Recipes
inline uint irng(uint rng_state)
{
    return 1664525u * rng_state + 1013904223u;
}

struct Image 
{
    uniform int width;
    uniform int height;
    uniform int depth;
	uniform float* data;
};

